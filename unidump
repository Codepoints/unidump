#!/usr/bin/env python3
"""
hexdump(1) for Unicode data
"""

import argparse
import doctest
import fileinput
import sys
import unicodedata


__version__ = '1.1'

default_lineformat = '{byte:>7}    {repr}    {data}\n'


def sanitize_char(char):
    """replace char with a dot, if it's a control or whitespace char

    Close to what hexdump does, but Unicode-aware. Characters that unicodedata
    is not aware of will also be replaced with a dot.

    >>> sanitize_char('A')
    'A'
    >>> sanitize_char('\U0001F678')
    '\U0001F678'
    >>> sanitize_char(' ')
    '.'
    >>> sanitize_char('\x01')
    '.'
    >>> # un-set Unicode character, should have category "Cn"
    >>> sanitize_char('\U000D0000')
    '.'
    >>> sanitize_char('a1')
    Traceback (most recent call last):
        ...
    TypeError: category() argument must be a unicode character, not str
    """
    category = unicodedata.category(char)
    if category[0] in ('C', 'Z'):
        return '.'
    return char


def print_line(line, linelength, lineformat=None):
    """
    >>> print_line([0, ['00A0', '00B0', '00C0'], 'ABC'], 4)
          0    00A0 00B0 00C0         ABC\n
    >>> print_line([12, ['00A0', '1F678', '00C0'], 'A\U0001F678C'], 4)
         12    00A0 1F678 00C0        A\U0001F678C\n
    """
    sys.stdout.write((lineformat or default_lineformat).format(
        byte=line[0],
        repr=' '.join(line[1]).ljust(linelength*5-1),
        data=line[2]
    ))


def fill_and_print_output(current_line, linelength, byteoffset, representation,
                          char, lineformat=None):
    """
    >>> current_line = [0, [], '']
    >>> current_line = fill_and_print_output(current_line, 2, 0, '0076', 'v')
    >>> current_line == [0, ['0076'], 'v']
    True
    >>> current_line = fill_and_print_output(current_line, 2, 1, '0076', 'v')
    >>> current_line = fill_and_print_output(current_line, 2, 2, '0077', 'w')
          0    0076 0076    vv\n
    >>> current_line == [1, ['0077'], 'w']
    True
    """
    if len(current_line[1]) >= linelength:
        print_line(current_line, linelength, lineformat)
        current_line = [byteoffset - 1, [representation], char]
    else:
        current_line[1].append(representation)
        current_line[2] += char

    return current_line


def unidump(input, linelength=16, encoding='utf-8', lineformat=None):
    """take a list of bytes and print their Unicode codepoints

    >>> import io
    >>> unidump(io.BytesIO(b'\\x01\\xF0\\x9F\\x99\\xB8ABC'), 4)
          0    0001 1F678 0041 0042    .\U0001F678AB
          7    0043                   C
    >>> unidump(io.BytesIO(b'\\xD7'), 4)
          0    ?D7?                   X
    >>> unidump(io.BytesIO(b'\\xD7'), 4, encoding='latin1')
          0    00D7                   \u00D7
    """

    byteoffset = 0
    bytebuffer = b''
    current_line = [0, [], '']

    byte = input.read(1)
    while byte:
        byteoffset += 1
        bytebuffer += byte

        try:
            char = bytebuffer.decode(encoding)
        except UnicodeDecodeError:
            next_byte = input.read(1)
            if not next_byte or len(bytebuffer) >= 4:
                for i, x in enumerate(bytebuffer):
                    current_line = (
                        fill_and_print_output(current_line, linelength,
                                              byteoffset - 3 + i,
                                              '?{:02X}?'.format(x), 'X',
                                              lineformat)
                    )
                bytebuffer = b''
            byte = next_byte
            continue
        else:
            current_line = (
                fill_and_print_output(current_line, linelength, byteoffset,
                                      '{:04X}'.format(ord(char)),
                                      sanitize_char(char), lineformat)
            )

        bytebuffer = b''
        byte = input.read(1)

    print_line(current_line, linelength, lineformat)


def main():
    description = (
        'A Unicode codepoint dump.\n\n'
        'Think of it as hexdump(1) for Unicode.  The command analyses the\n'
        'input  and prints then three columns:  the raw byte count of the\n'
        'first codepoint  in this row,  codepoints in their hex notation,\n'
        'and finally the raw input characters with control and whitespace\n'
        'replaced by a dot.\n\n'
        'Invalid byte sequences are represented with an “X”  and with the\n'
        'hex value enclosed in question marks, e.g., “?F5?”.\n\n'
        'You can pipe in  data from stdin,  select several files at once,\n'
        'or mix all those input methods together.'
    )
    parser = argparse.ArgumentParser(
        description=description,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument('files', nargs='*', metavar='FILE', default=('-',),
                        help='input files. Use `-\' or keep empty for stdin.')
    parser.add_argument('-n', '--length', type=int, default=16,
                        help='format output using this much input characters. '
                        'Default is %(default)s characters.')
    parser.add_argument('-c', '--encoding', type=str, default='utf-8',
                        metavar='ENC',
                        help='interpret input in this encoding. Default is '
                        '%(default)s. You can choose any encoding that Python '
                        'supports, e.g. “latin-1”.')
    parser.add_argument('-e', '--format', type=str, default=default_lineformat,
                        help='specify a custom format in Python’s {} notation.'
                        ' Default is “%(default)s”.')
    parser.add_argument('-v', '--version', action='version',
                        version='%(prog)s {}'.format(__version__))

    a = parser.parse_args()

    try:
        for filename in a.files:
            if filename == '-':
                infile = sys.stdin.buffer
            else:
                try:
                    infile = open(filename, 'rb')
                except FileNotFoundError:
                    sys.stdout.flush()
                    sys.stderr.write('File {} not found.\n'.format(filename))
                    continue
            unidump(infile, a.length, a.encoding, a.format)
    except KeyboardInterrupt:
        sys.stdout.flush()
        # sys.stderr.write('Interrupted\n')
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == '__main__':
    if '--self-test' in sys.argv:
        doctest.testmod(verbose=('--verbose' in sys.argv))
    else:
        main()
